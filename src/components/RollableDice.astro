---
// src/components/RollableDiceAstroTooltip.astro
// This component assumes its JavaScript is bundled and runs ONCE for ALL instances
// It uses querySelectorAll to find all instances and initialize them.

interface Props {
  formula?: string;
  originalText?: string;
}

const { formula = '1d6', originalText } = Astro.props;
const effectiveOriginalText = originalText || formula;

// Using a universal class for the component wrapper
const componentWrapperClass = 'rollable-dice-component-wrapper';
---

<div class={componentWrapperClass}
     data-formula={formula}
     data-original-text={effectiveOriginalText}
>
  <button class="rollable-dice-button">
    {effectiveOriginalText}
  </button>

  <!-- Tooltip element, hidden by default -->
  <div class="rollable-dice-tooltip" style="display: none;">
    <div class="tooltip-content"></div>
    <div class="tooltip-arrow"></div>
  </div>
</div>

<script>
  // We import the same logic from our utility file
  import { evaluateExpression, rollDie } from '../utils/diceRoller';

  // Find all instances of the component wrapper on the page
  const componentWrappers = document.querySelectorAll('.rollable-dice-component-wrapper');

  componentWrappers.forEach(componentWrapper => {
    // Get the button and tooltip within this specific component instance
    const button = componentWrapper.querySelector('.rollable-dice-button') as HTMLButtonElement | null;
    const tooltip = componentWrapper.querySelector('.rollable-dice-tooltip') as HTMLDivElement | null;
    const tooltipContentElement = tooltip?.querySelector('.tooltip-content');

    if (button && tooltip && tooltipContentElement) {
      // --- Initialization logic for THIS component instance ---
      let tooltipTimeoutId: NodeJS.Timeout | null = null;
      let isRolling = false;

      // Get formula and originalText from data attributes on the wrapper
      const formula = (componentWrapper as HTMLElement).dataset.formula || '1d6';

      const showTooltip = (content: string, buttonRect: DOMRect) => {
        tooltipContentElement.textContent = content;
        tooltip.style.display = 'block';

        requestAnimationFrame(() => {
          const top = buttonRect.top - tooltip.offsetHeight - 10;
          const left = buttonRect.left + buttonRect.width / 2;

          tooltip.style.top = `${top}px`;
          tooltip.style.left = `${left}px`;
          tooltip.style.transform = 'translateX(-50%)';
          tooltip.style.opacity = '1';
        });
      };

      const hideTooltip = () => {
        tooltip.style.opacity = '0';
        setTimeout(() => {
          tooltip.style.display = 'none';
          tooltipContentElement.textContent = '';
        }, 3000); // Match transition duration
      };

      const handleRoll = () => {
        if (isRolling) return;
        console.debug('Roll initiated for formula:', formula);
        isRolling = true;
        button.disabled = true;

        if (tooltipTimeoutId) {
          clearTimeout(tooltipTimeoutId);
        }
        hideTooltip();

        let resultFormula = formula;
        const diceRegex = /(\d+)?d(\d+)/gi;

        let match: RegExpExecArray | null;
        let tempFormula = formula;
        const replacementMap = new Map<string, number>();

        while ((match = diceRegex.exec(tempFormula)) !== null) {
          const fullMatch = match[0];
          const numDice = parseInt(match[1] || '1', 10);
          const sides = parseInt(match[2], 10);

          if (isNaN(numDice) || isNaN(sides) || sides <= 0) {
            console.error('Invalid dice notation:', fullMatch);
            showTooltip('Error', button.getBoundingClientRect());
            isRolling = false;
            tooltipTimeoutId = setTimeout(() => {
              hideTooltip();
              button.disabled = false;
              console.debug('Resetting display (error).');
            }, 3000);
            return;
          }

          let rollSum = 0;
          for (let i = 0; i < numDice; i++) {
            const roll = rollDie(sides);
            rollSum += roll;
            console.debug(`Rolled ${roll} on d${sides}`);
          }
          replacementMap.set(fullMatch, rollSum);
        }

        replacementMap.forEach((sum, notation) => {
          resultFormula = resultFormula.replace(new RegExp(notation, 'g'), sum.toString());
        });

        console.debug('Final formula for evaluation:', resultFormula);
        const finalResult = evaluateExpression(resultFormula);
        const resultString = isNaN(finalResult) ? 'Error' : finalResult.toString();

        showTooltip(resultString, button.getBoundingClientRect());

        tooltipTimeoutId = setTimeout(() => {
          hideTooltip();
          isRolling = false;
          button.disabled = false;
          console.debug('Tooltip hidden, roll finished.');
        }, 2500);
      };

      button.addEventListener('click', handleRoll);

      // Cleanup listener when the component is removed from the DOM
      // (e.g., via Astro's View Transitions API)
      const cleanupListener = () => {
        if (!button.isConnected) { // Check if button is no longer in the DOM
          button.removeEventListener('click', handleRoll);
          if (tooltipTimeoutId) {
            clearTimeout(tooltipTimeoutId);
          }
          // Remove this specific instance's cleanup listener to prevent memory leaks
          document.removeEventListener('astro:before-swap', cleanupListener);
        }
      };
      document.addEventListener('astro:before-swap', cleanupListener);
    }
  });
</script>